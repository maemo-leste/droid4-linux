diff --git a/arch/arm/boot/dts/motorola-mapphone-common.dtsi b/arch/arm/boot/dts/motorola-mapphone-common.dtsi
index 604058627cf3..fa6025706180 100644
--- a/arch/arm/boot/dts/motorola-mapphone-common.dtsi
+++ b/arch/arm/boot/dts/motorola-mapphone-common.dtsi
@@ -24,6 +24,26 @@ memory {
 		reg = <0x80000000 0x3fd00000>;	/* 1021 MB */
 	};
 
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		/*
+		 * The stock kernel has 2M@0xa0000000 for ram_console using the
+		 * old file format. That won't work for us, so let's ignore the
+		 * first 512K of that and just overwrite the rest and configure
+		 * only 384K instead of 2M.
+		 */
+		ramoops@a0080000 {
+			compatible = "ramoops";
+			reg = <0xa0080000 0x60000>;
+			record-size = <0x20000>;
+			console-size = <0x20000>;
+			ftrace-size = <0x20000>;
+		};
+	};
+
 	/* Poweroff GPIO probably connected to CPCAP */
 	gpio-poweroff {
 		compatible = "gpio-poweroff";
diff --git a/arch/arm/configs/omap2plus_defconfig b/arch/arm/configs/omap2plus_defconfig
index 760dc0b41c19..e1f0b883b17f 100644
--- a/arch/arm/configs/omap2plus_defconfig
+++ b/arch/arm/configs/omap2plus_defconfig
@@ -669,6 +669,11 @@ CONFIG_JFFS2_LZO=y
 CONFIG_JFFS2_RUBIN=y
 CONFIG_UBIFS_FS=y
 CONFIG_CRAMFS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_FTRACE=y
+CONFIG_PSTORE_RAM=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3_ACL=y
 CONFIG_NFS_V4=y
diff --git a/arch/arm/mach-omap2/prm44xx.c b/arch/arm/mach-omap2/prm44xx.c
index 25093c1e5b9a..05e2f654585a 100644
--- a/arch/arm/mach-omap2/prm44xx.c
+++ b/arch/arm/mach-omap2/prm44xx.c
@@ -831,6 +831,17 @@ int __init omap44xx_prm_init(const struct omap_prcm_init_data *data)
 		cpu_pm_register_notifier(&nb);
 	}
 
+#ifdef CONFIG_PSTORE
+	/*
+	 * On droid4, the stock kernel configured reset times will clear
+	 * DDR on warm reset. Set the reset times to TRM defaults, the
+	 * stock kernel uses custom values of 16 and 200.
+	 */
+	if (of_machine_is_compatible("motorola,droid4") ||
+	    of_machine_is_compatible("motorola,bionic"))
+		omap4_prminst_global_reset_time(16, 6);
+#endif
+
 	return prm_register(&omap44xx_prm_ll_data);
 }
 
diff --git a/arch/arm/mach-omap2/prminst44xx.c b/arch/arm/mach-omap2/prminst44xx.c
index fc086d8b9a04..640c0f998dcd 100644
--- a/arch/arm/mach-omap2/prminst44xx.c
+++ b/arch/arm/mach-omap2/prminst44xx.c
@@ -174,6 +174,41 @@ int omap4_prminst_deassert_hardreset(u8 shift, u8 st_shift, u8 part, s16 inst,
 	return (c == MAX_MODULE_HARDRESET_WAIT) ? -EBUSY : 0;
 }
 
+/**
+ * omap4_prminst_global_reset_time - configure hardwar reset register
+ * @pwrdm_cycles: power domain reset duration in clock cycles
+ * @reset_cycles: reset duration in clock cycles
+ *
+ * Configures the PRM_RSTTIME as documented in TRM. If no values are passed,
+ * Use the TRM default reset values instead.
+ */
+void omap4_prminst_global_reset_time(int pwrdm_cycles,
+				     int reset_cycles)
+{
+	s32 inst = omap4_prmst_get_prm_dev_inst();
+	u32 v = 0;
+
+	if (inst == PRM_INSTANCE_UNKNOWN)
+		return;
+
+	/* The smallest writable values are 1, use defaults if not specified */
+	if (pwrdm_cycles < 1)
+		v = 0x10 << 10;
+	else
+		v = (pwrdm_cycles & 0x1f) << 10;
+
+	if (reset_cycles < 1)
+		v |= 0x6;
+	else
+		v |= reset_cycles & 0x3ff;
+
+	omap4_prminst_write_inst_reg(v, OMAP4430_PRM_PARTITION,
+				     inst, OMAP4_PRM_RSTTIME_OFFSET);
+
+	/* OCP barrier */
+	v = omap4_prminst_read_inst_reg(OMAP4430_PRM_PARTITION,
+					inst, OMAP4_PRM_RSTTIME_OFFSET);
+}
 
 void omap4_prminst_global_warm_sw_reset(void)
 {
diff --git a/arch/arm/mach-omap2/prminst44xx.h b/arch/arm/mach-omap2/prminst44xx.h
index 11365a08e833..75c85a8ebd1c 100644
--- a/arch/arm/mach-omap2/prminst44xx.h
+++ b/arch/arm/mach-omap2/prminst44xx.h
@@ -22,6 +22,9 @@ extern void omap4_prminst_write_inst_reg(u32 val, u8 part, s16 inst, u16 idx);
 extern u32 omap4_prminst_rmw_inst_reg_bits(u32 mask, u32 bits, u8 part,
 					   s16 inst, u16 idx);
 
+extern void omap4_prminst_global_reset_time(int pwrdm_cycles,
+					    int reset_cycles);
+
 extern void omap4_prminst_global_warm_sw_reset(void);
 
 extern int omap4_prminst_is_hardreset_asserted(u8 shift, u8 part, s16 inst,
diff --git a/drivers/mfd/motorola-cpcap.c b/drivers/mfd/motorola-cpcap.c
index 30d82bfe5b02..be138ba6e4fb 100644
--- a/drivers/mfd/motorola-cpcap.c
+++ b/drivers/mfd/motorola-cpcap.c
@@ -24,6 +24,23 @@
 #define CPCAP_REGISTER_SIZE	4
 #define CPCAP_REGISTER_BITS	16
 
+/* Register CPCAP_REG_VAL1 bits */
+#define CPCAP_BIT_NVFLASH_MODE		BIT(14)
+#define CPCAP_BIT_RECOVERY_MODE		BIT(13)
+#define CPCAP_BIT_FASTBOOT_MODE		BIT(12)	/* Nope, not for fastboot */
+#define CPCAP_BIT_BOOT_MODE		BIT(11)	/* For fastboot mode */
+#define CPCAP_BIT_BP2_ONLY_FLASH	BIT(10)
+#define CPCAP_BIT_OUT_CHARGE_ONLY	BIT(9)
+#define CPCAP_BIT_USB_BATT_RECOVERY	BIT(8)
+#define CPCAP_BIT_PANIC			BIT(7)
+#define CPCAP_BIT_BP_ONLY_FLASH		BIT(6)
+#define CPCAP_BIT_WATCHDOG_RESET	BIT(5)
+#define CPCAP_BIT_SOFT_RESET		BIT(4)
+#define CPCAP_BIT_FLASH_FAIL		BIT(3)
+#define CPCAP_BIT_FOTA_MODE		BIT(2)
+#define CPCAP_BIT_AP_KERNEL_PANIC	BIT(1)
+#define CPCAP_BIT_FLASH_MODE		BIT(0)
+
 struct cpcap_ddata {
 	struct spi_device *spi;
 	struct regmap_irq *irqs;
@@ -85,6 +102,32 @@ static int cpcap_check_revision(struct cpcap_ddata *cpcap)
 	return 0;
 }
 
+static int cpcap_init_registers(struct cpcap_ddata *ddata)
+{
+	u16 val;
+	int err;
+
+	/* Stock kernel default values on power up */
+	val = CPCAP_BIT_OUT_CHARGE_ONLY | CPCAP_BIT_SOFT_RESET |
+		CPCAP_BIT_AP_KERNEL_PANIC;
+
+#ifdef CONFIG_PSTORE
+	/*
+	 * The CPCAP_BIT_PANIC seems to prevent the bootloader from clearing
+	 * the DDR memory. For pstore, also SoC PRM_RSTTIME needs to be set
+	 * to minimum values of 0x401.
+	 */
+	val |= CPCAP_BIT_PANIC;
+#endif
+
+	err = regmap_update_bits(ddata->regmap, CPCAP_REG_VAL1,
+				 0xffff, val);
+	if (err)
+		return err;
+
+	return 0;
+}
+
 /*
  * First two irq chips are the two private macro interrupt chips, the third
  * irq chip is for register banks 1 - 4 and is available for drivers to use.
@@ -323,6 +366,10 @@ static int cpcap_probe(struct spi_device *spi)
 		return ret;
 	}
 
+	ret = cpcap_init_registers(cpcap);
+	if (ret)
+		return ret;
+
 	ret = cpcap_init_irq(cpcap);
 	if (ret)
 		return ret;
